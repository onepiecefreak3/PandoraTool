using Microsoft.CodeAnalysis;
using System.Text;

namespace Logic.Domain.PandoraManagement.Generation;

[Generator]
public sealed class ScriptInstructionComposerGenerator : IIncrementalGenerator
{
    private const string AttributeName = "Logic.Domain.PandoraManagement.Script.Instructions.ScriptInstructionAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var attributes = context.SyntaxProvider.ForAttributeWithMetadataName(AttributeName, (_, _) => true, (attrCtx, _) => attrCtx.Attributes).SelectMany((a, _) => a);
        context.RegisterSourceOutput(attributes, GenerateComposer);
    }

    private void GenerateComposer(SourceProductionContext productionContext, AttributeData attribute)
    {
        var instruction = (int)attribute.ConstructorArguments[0].Value!;
        var expression = (string?)attribute.ConstructorArguments[1].Value!;
        var isManual = (bool)attribute.ConstructorArguments[2].Value!;

        if (isManual)
        {
            productionContext.AddSource($"Instruction{instruction}Composer.g.cs",
                $$"""
                  // <auto-generated />
                  using Logic.Domain.PandoraManagement.Contract.DataClasses.Script;

                  namespace Logic.Domain.PandoraManagement.Script.Instructions;

                  internal partial class Instruction{{instruction}}Composer : ScriptInstructionComposer
                  {
                      private static readonly Lazy<Instruction{{instruction}}Composer> Lazy = new(() => new Instruction{{instruction}}Composer());
                      
                      public static Instruction{{instruction}}Composer Instance => Lazy.Value;
                  }
                  """);
        }
        else
        {
            var sb = new StringBuilder();
            ProcessExpression(sb, expression);

            productionContext.AddSource($"Instruction{instruction}Composer.g.cs",
                $$"""
                // <auto-generated />
                using Logic.Domain.PandoraManagement.Contract.DataClasses.Script;

                namespace Logic.Domain.PandoraManagement.Script.Instructions;

                internal class Instruction{{instruction}}Composer : ScriptInstructionComposer
                {
                    private static readonly Lazy<Instruction{{instruction}}Composer> Lazy = new(() => new Instruction{{instruction}}Composer());
                    
                    public static Instruction{{instruction}}Composer Instance => Lazy.Value;
                    
                    protected override void ComposeArguments(ScriptInstruction instruction, Dictionary<string, int> jumpLookup, List<ScriptArgumentData> arguments, ref int offset)
                    {
                        int argumentIndex = 0;
                {{sb}}    }
                }
                """);
        }
    }

    private static void ProcessExpression(StringBuilder sb, string? expression)
    {
        if (string.IsNullOrWhiteSpace(expression))
            return;

        var index = 0;
        ProcessExpression(sb, expression, ref index, 2);
    }

    private static void ProcessExpression(StringBuilder sb, string? expression, ref int i, int tab)
    {
        if (string.IsNullOrWhiteSpace(expression))
            return;

        for (; i < expression!.Length;)
        {
            if (expression[i] is '*')
            {
                sb.AppendLine($"{new string(' ', tab * 4)}while (argumentIndex < instruction.Arguments.Length)");
                sb.AppendLine($"{new string(' ', tab * 4)}{{");

                i++;
                if (expression[i] is '(')
                {
                    i++;
                    ProcessSubExpression(sb, expression, ref i, tab);
                }
                else
                {
                    ProcessArgumentExpression(sb, expression, ref i, 1, tab + 1);
                }

                sb.AppendLine($"{new string(' ', tab * 4)}}}");
                break;
            }

            if (expression[i] is '|')
            {
                sb.AppendLine($"{new string(' ', tab * 4)}if (instruction.Arguments.Length > argumentIndex)");
                sb.AppendLine($"{new string(' ', tab * 4)}{{");

                i++;
                ProcessExpression(sb, expression, ref i, tab + 1);

                sb.AppendLine($"{new string(' ', tab * 4)}}}");
            }
            else if (expression[i] is '(')
            {
                i++;
                ProcessSubExpression(sb, expression, ref i, tab);
            }
            else if (expression[i] is >= '0' and <= '9')
            {
                ProcessArgumentExpression(sb, expression, ref i, tab);
            }
            else
            {
                break;
            }
        }
    }

    private static void ProcessSubExpression(StringBuilder sb, string expression, ref int i, int tab)
    {
        int closingIndex = expression.IndexOf(')', i);
        if (closingIndex < 0)
            return;

        string subExpression = expression.Substring(i, closingIndex - i);

        var j = 0;
        ProcessExpression(sb, subExpression, ref j, tab);

        i = closingIndex + 1;
    }

    private static void ProcessArgumentExpression(StringBuilder sb, string expression, ref int i, int tab)
    {
        int countStart = i;
        while (expression[i] is >= '0' and <= '9')
            i++;

        int count = int.Parse(expression.Substring(countStart, i - countStart));

        ProcessArgumentExpression(sb, expression, ref i, count, tab);
    }

    private static void ProcessArgumentExpression(StringBuilder sb, string expression, ref int i, int count, int tab)
    {
        char mode = expression[i++];
        if (mode is not 'c' and not 'v' and not 's' and not 'j')
            return;

        ProcessArgumentExpression(sb, mode, count, tab);
    }

    private static void ProcessArgumentExpression(StringBuilder sb, char mode, int count, int tab)
    {
        for (var j = 0; j < count; j++)
        {
            switch (mode)
            {
                case 'c':
                    sb.AppendLine($"{new string(' ', tab * 4)}ComposeValueData(instruction, argumentIndex++, arguments, ref offset);");
                    break;

                case 'v':
                    sb.AppendLine($"{new string(' ', tab * 4)}ComposeVariableData(instruction, argumentIndex++, arguments, ref offset);");
                    break;

                case 's':
                    sb.AppendLine($"{new string(' ', tab * 4)}ComposeStringData(instruction, argumentIndex++, arguments, ref offset);");
                    break;

                case 'j':
                    sb.AppendLine($"{new string(' ', tab * 4)}ComposeJumpData(instruction, argumentIndex++, jumpLookup, arguments, ref offset);");
                    break;

                case 'i':
                    sb.AppendLine($"{new string(' ', tab * 4)}ComposeInt32(instruction, argumentIndex++, jumpLookup, arguments, ref offset, out _);");
                    break;
            }
        }
    }
}